#include<iostream>
using namespace std;

/*
- 포인터는 주소를 저장하는 변수
- 모든 데이터들은 메모리 상에 특정한 공간에 저장
- 기존의 변수는 데이터를 저장하는데 비해 포인터는 메모리 공간의 주소를 저장
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야 한다
ㄴ 변수 이름 앞에 &연산자를 붙인다(&:주소리턴기능)
ㄴ 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 *연산자를 붙인다

- 포인터 연산자
& : 특정한 데이터의 메모리 상의 주소값을 알 수 있다.
* : & 연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 반대로 주소값에서
해당 주소값에 대응되는 데이터를 가져오는 연산자

int a;
Pointer(라는 타입이 있다면)* p;
p = &a;

*/

int main() {
	//int* p;		// 포인터 변수 p 선언
	//int a;
	//// p = 10;	// 우리가 흔히 알고 있는 데이터는 저장 불가
	//p = &a;		// a의 주소값을 저장

	//cout << "p의 값(a의 주소값) : " << p << "\n";
	//cout << "a의 값 : " << a << "\n";
	//cout << "*p의 값 : " << *p << "\n";

	cout << "================================\n";

	int num = 10;
	cout << "num의 값 : " << num << "\n";
	cout << "\n";
	cout << "num의 주소값 : " << &num << "\n";
	cout << "\n";
	int* p = &num;	// num의 주소를 저장
	cout << "포인터 변수 p의 값 : " << p << "\n";
	cout << "\n";
	cout << "p의 주소값 : " << &p << "\n";
	cout << "\n";
	cout << "p의 역참조(num의 값) : " << *p << "\n";

	*p = 777;

	cout << "역참조 후(num값) : " << num << "\n";

	int** pp; // 이중포인터(더블포인터) : 포인터 변수의 주소를 저장

	int b;
	pp = &p;

	cout << "pp의 값 (포인터 변수 p의 주소) : " << pp << "\n";

	**pp = 1234;

	cout << "변경된 num의 값 : " << num << "\n";

	// callbyRef
	// callbyValue
}